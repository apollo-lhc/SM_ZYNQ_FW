#!/usr/bin/env python3

#################################################################################
## Force python3
#################################################################################
import sys
if not sys.version_info.major == 3:
    raise BaseException("Wrong Python version detected.  Please ensure that you are using Python 3.")
#################################################################################
import argparse

import os

from enum import Enum
class ParseState(Enum):
    START     = 0
    PREAMBLE  = 1
    CONFIG    = 2
    POSTAMBLE = 3
    END       = 4
    
def ParseRegLine(line,regs,reg_page):
    #validate line
    if (line[0] == "0" and 
        line[1] == "x" and
        line[6] == "," and
        line[7] == "0" and 
        line[8] == "x"):
        page=int(line[2:4],base=16)
        address=int(line[4:6],base=16)
        data=int(line[7:11],base=16)
        if(page != reg_page):
            regs.append(((1<<8) + page))
            reg_page = page
        regs.append(((address << 8) + data))
    return regs,reg_page
    

def PrintArrays(name,regs,outfile=sys.stdout):
    reg_count = len(regs)
    if reg_count == 0:
        return

    regs_per_line=8
    regs_on_line=0    
    padding=" "

    outfile.write("u16 "+name+"[] = { \n")    
    
    for i in range(0,reg_count):
        
        if regs_on_line >= regs_per_line:
            outfile.write("\n"+2*padding)
            regs_on_line = 0
        elif regs[i]>>8 == 0x1:
            if i != 0:
                outfile.write("\n")
            outfile.write(2*padding)
            regs_on_line = 0
        outfile.write(" 0x"+hex(regs[i])[2:].zfill(4))            
        if i < reg_count-1:
            outfile.write(", ")
        if regs[i]>>8 == 0x1:
            outfile.write("// Page 0x"+hex(regs[i]&0xFF)[2:].zfill(2)+"\n")            
            outfile.write(2*padding)
            regs_on_line = 0
        regs_on_line=regs_on_line+1
    outfile.write("\n};\n")

def GetRegWrites(filename):
    inFile = open(filename,"r")

    preamble  = []
    config    = []
    postamble = []

    state = ParseState.START
    reg_page = -1

    for line in inFile:
        #find Start config preamble    
        if state == ParseState.START:
            if line.find("# Start configuration preamble") >= 0:
                state = ParseState.PREAMBLE
                reg_page = -1
        #capture the preamble
        elif state == ParseState.PREAMBLE:
            if line.find("# Start configuration registers") >= 0:
                state = ParseState.CONFIG
                reg_page = -1
            elif line[0] != "#":
                preamble,reg_page = ParseRegLine(line,preamble,reg_page)
        #capture the config
        elif state == ParseState.CONFIG:
            if line.find("# Start configuration postamble") >= 0:
                state = ParseState.POSTAMBLE
                reg_page = -1
            elif line[0] != "#":
                config,reg_page = ParseRegLine(line,config,reg_page)
        #capture the postamble
        elif state == ParseState.POSTAMBLE:
            if line[0] != "#":
                postamble,reg_page = ParseRegLine(line,postamble,reg_page)

    return preamble,config,postamble







def main(out_filename,file_list,i2c_addr_list,serv_offset_list):
    outfile = open(out_filename,'w')

    file_count = len(file_list)

    #write the header of the si_data.c
    outfile.write("#include \"si_data.h\"\n")    
    outfile.write("#include \"AXI_slave_addrs.h\" // autogenerated list of addresses in FW \n")


    for iFile in range(0,file_count):
        name=os.path.basename(file_list[iFile][0:file_list[iFile].find(".txt")])
        name=name.replace("-","_")
        #get the three sections of code from this file
        preamble,config,postamble = GetRegWrites(file_list[iFile])
        PrintArrays(name,preamble+config+postamble,outfile)


    outfile.write("sProgramSI localConfigs[" + str(file_count) + "];\n")
    outfile.write("void siConfigInit(){\n")
    outfile.write("  siConfigCount = " +        str(file_count) + ";\n")

    for iFile in range(0,file_count):
        name=os.path.basename(file_list[iFile][0:file_list[iFile].find(".txt")])
        name=name.replace("-","_")
        #build the struct

        outfile.write("  localConfigs["+str(iFile)+"].i2c_AXIBaseAddr   = AXI_ADDR_SI;\n")
        outfile.write("  localConfigs["+str(iFile)+"].si_enable_AXIAddr = AXI_ADDR_SERV +"+str(serv_offset_list[iFile])+";\n")
        outfile.write("  localConfigs["+str(iFile)+"].si_enable_MASK    = 0x2;\n")
        outfile.write("  localConfigs["+str(iFile)+"].si_oe_AXIAddr     = AXI_ADDR_SERV +"+str(serv_offset_list[iFile])+";\n")
        outfile.write("  localConfigs["+str(iFile)+"].si_oe_MASK        = 0x1;\n")
        outfile.write("  localConfigs["+str(iFile)+"].si_locked_AXIAddr = AXI_ADDR_SERV +"+str(serv_offset_list[iFile])+";\n")
        outfile.write("  localConfigs["+str(iFile)+"].si_locked_MASK    = 0x6;\n")
        outfile.write("  localConfigs["+str(iFile)+"].data              = " + name + ";\n")
        outfile.write("  localConfigs["+str(iFile)+"].data_init_size    = " + str(len(preamble)) + ";\n")
        outfile.write("  localConfigs["+str(iFile)+"].data_size         = " + str(len(preamble)+len(config)+len(postamble))+";\n")
        outfile.write("  localConfigs["+str(iFile)+"].data_init_usleep  = 400000;\n")
        outfile.write("  localConfigs["+str(iFile)+"].name              = \"" + name + "\";\n")
        outfile.write("  localConfigs["+str(iFile)+"].i2c_address       = "+str(i2c_addr_list[iFile])+";\n")

    outfile.write("  siConfigs = localConfigs;")
    outfile.write("}\n\n\n")
 

#        print(si_file)
#        

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Generate fsbl data file for Si chips')
    parser.add_argument('-f','--files', 
                        action='append', required=True,
                        help='files to be programmed in the fsbl')
    parser.add_argument('-i','--i2caddr', 
                        action='append', required=True,
                        help='address of i2c slaves for each file (order must match file list)')
    parser.add_argument('-s','--si_serve_offset', 
                        action='append', required=True,
                        help='address offset in the serv endpoint for the si\'s ios (order must match file list)')
    parser.add_argument('--outfile', help='outfile name', required=True)
    args = parser.parse_args()    
    if len(args.files) != len(args.i2caddr) or len(args.files) != len(args.si_serve_offset):
        print("count of files, i2caddrs, and si_serve_offsets must match")
        parser.print_help()
        exit(1)
    main(args.outfile,args.files,args.i2caddr,args.si_serve_offset)
